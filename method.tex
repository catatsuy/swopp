\subsection{最適化の方針}

ここでは \ref{ss:profiling} 章で述べたように，ArchHDL::Step() と
reg::Update() の処理を高速化することを考える．

最適化の方針として逐次プログラミングにおける最適化と並列化における最適化の両方を考える．

\subsection{逐次プログラムにおける高速化手法}

\subsubsection{データ変更の有無による条件分岐の除去 \label{sss:no_set}}

\figref{src:reg} に示した実装では，reg
クラスのインスタンスの値を更新する方法としてブロッキング代入とノンブロッキング代入の
2 つが存在する．

まずノンブロッキング代入について考える．reg
クラスのインスタンスにノンブロッキング代入が行われた時にメンバ変数 set\_
を true にし，メンバ変数 next\_ に値を代入する．そして reg::Update
内では set\_ が true の時だけ next\_ をメンバ変数 curr\_
に代入する．これは reg
クラスのインスタンスの値を変更したサイクルのみで，その reg
クラスのインスタンスの値を次サイクルに移る前に新しい値に更新することを意味する．

\figref{src:reg} に示した実装では，更新されない reg
クラスのインスタンスの curr\_ と next\_
の値が同じであるため，代入する処理を行う必要はない．よって set\_
変数を用いて不要な代入を避けている．reg
クラスのインスタンスの更新頻度が低い回路であればこの実装が効率的である．

次にブロッキング代入について考える．reg
クラスのインスタンスにブロッキング代入が行われた時に curr\_
の値を書き換える．

提案手法について述べる．この set\_ 変数が true
の時のみ代入するのではなく，次サイクルに移る前に next\_ の値を curr\_
に常に代入するようにする．こうすることによって分岐のオーバーヘッドが無くなるため，ノンブロッキング代入が頻繁に行われる回路で速度向上が期待できる．

\subsubsection{値を配列として格納しポインタ参照を削減} \label{sss:mem_copy}

\begin{figure}[t]
 \centering
 \includegraphics[clip,width=\linewidth-30pt]{simple_reg}
 \caption{シンプルな実装による reg クラスのインスタンスの処理の様子}
 \label{fig:regs}
\end{figure}

\figref{fig:regs} はシンプルな実装による reg クラスのインスタンスの処理の様子である．\figref{src:class_singleton}
の 44 行から 46 行の処理を表している．reg クラスのインスタンスが灰色に塗られており，左からクラスのメタデータ，next\_，curr\_
を表している．左側の大きな枠が示した実装の \verb`std::vector` 型の registers\_ である．
実線矢印は代入を表し．点線矢印はポインタ参照を表す．

registers\_ の値を上から順に辿る．最初の reg クラスのインスタンスの reg::Update() メソッドを呼び，next\_ の値が curr\_ に代入される．これを全 reg クラスのインスタンスにおいて行う．

\ref{sss:no_set} 節で述べたデータ変更の有無による条件分岐の除去を行うと
reg::Update() メソッド内で行なっている reg
クラスのインスタンスの curr\_ に next\_ の値を代入する処理は毎サイクル全
reg クラスのインスタンスで実行されることになる．

この代入する処理と reg::Update() メソッド自体の関数呼び出しの 2
つのオーバーヘッドが\tabref{table:stencil_prof} で示すようにArchHDL
の高速化を妨げている．

\begin{figure}[t]
 \centering
 \includegraphics[clip,width=\linewidth-30pt]{mem_copy}
 \caption{値を配列として格納しポインタ参照を削減するようにした reg クラスのインスタンスの処理の様子}
 \label{fig:mem_copy}
\end{figure}

\figref{fig:mem_copy} に値を配列として格納しポインタ参照を削減するようにした reg クラスのインスタンスの処理の様子を示す．reg クラスのインスタンスが灰色に塗られており，左からクラスのメタデータ，next\_，curr\_ を表している．
下の枠が next\_ と curr\_ の値をまとめた配列であり，ここでは next collections, curr collections と呼ぶ．
実線矢印は代入を表し．点線矢印はポインタ参照を表す．

全 reg クラスのインスタンスは現在の値と次サイクルの値の実体は持たず，ポインタを保持するようにする．実体はそれぞれ配列として持つ．

次サイクルに移る前に行われる curr\_ に next\_ の値を代入する処理は \figref{fig:regs} で示すようにシンプルな実装では registers\_ から reg クラスのインスタンスが存在するアドレスを調べる必要がある．
しかし値を配列として格納しポインタ参照を削減するようにすると \figref{fig:mem_copy} に示すように単純なメモリの並びを代入するだけになる．これにより代入する処理が高速になることが期待される．

またこの手法によって reg::Update() 自体の関数呼び出しがなくなり，関数呼び出しのオーバーヘッドもなくなる．

実装は 2 つの大きな配列を用意する．その配列内に reg クラスのインスタンス宣言時に記述した型に応じた領域を確保する．
reg クラスのコンストラクタで next\_ と curr\_ の値が存在するアドレスを取得し，インスタンスでそれを保持する．
これまで reg クラスの全インスタンスの reg::Update() メソッドを呼び出していたところを next\_ collections から curr\_ collections の値コピーに変更する．


\subsubsection{ダブルバッファリング}

これまでの実装では \ref{ss:implementation} 章で述べたように reg
クラスのインスタンスの次サイクルの値が次サイクルに移る前に reg
クラスのインスタンスの現在の値に代入される．
そこで偶数回目の実行と奇数回目の実行で次サイクルの値と現在の値を格納している変数を
を入れ替えれば（ダブルバッファリング）代入が減ることが期待できる．

\begin{figure}[t]
 \begin{center}
  \input{img/reg_curr_next}
 \end{center}
 \caption{reg クラスのインスタンスの変数保持の処理の様子}
 \label{fig:reg_curr_next}
\end{figure}

\begin{figure}[t]
 \begin{center}
  \input{img/double_buffer2}
 \end{center}
 \caption{ダブルバッファリングの処理の様子}
 \label{fig:double_buffer}
\end{figure}

\figref{fig:reg_curr_next} はこれまでの ArchHDL の reg
クラスのインスタンスの値の保持のイメージである．読み込み用と書き込み用の変数をそれぞれ保持している．読み込み用が現在の値であり，書き込み用が次サイクルの値である，次サイクルに移る前に書き込み用の値が読み込み用の変数に書き込まれる．

\figref{fig:double_buffer}
はダブルバッファリングのイメージである．奇数回目のサイクルと偶数回目のサイクルで読み込み用と書き込み用の変数を入れ替える．これにより奇数回目のサイクルで書き込み用であった変数には値が書き込まれているので次サイクルの偶数回目のサイクルで読み込み用として使用出来る．これを繰り返すことで，次サイクルに移る前に行われる代入処理を無くせる．

しかし今回の手法では reg
クラスのインスタンスへ値の書き込みが行われなかった場合に reg
クラスのインスタンスのその時の書き込み用の値に更新が入らない．次サイクルではその書き込み用の値がそのまま現在の値として使用されるので古い値が使われてしまう．そのため単純に入れ替えるだけの実装では誤ったシュミレーションを行なってしまう．

また今回の手法はサイクルの回数で依存関係が発生するので \ref{ss:parallel}
節で述べる並列化ができない．

よってライブラリの実装として導入するのは困難であるが，reg
クラスのインスタンスへ常に書き込みが行われるカウンター回路で試したところ効果があった（具体的な数字）．常に
reg
クラスのインスタンスに書き込みが行われるハードウェアシュミレーションを逐次処理で行いたい場合には高い効果が期待できる．

以上の理由から本論文ではダブルバッファリングによる評価は行わない．

\subsection{並列化による高速化 \label{ss:parallel}}

一方で並列化による高速化では \figref{src:class_singleton} に示すように
ArchHDL の Singleton クラスの Exec() メソッド内の for 文内で
Module::Always() メソッドと reg::Update()
メソッドは毎サイクル，各クラスの全インスタンスで呼び出されている．
モジュールの実行とレジスタの更新はそれぞれ独立に行えるので容易に並列化が可能である．

今回は for 文などの並列化を行いたい部分の前に \verb/#pragma omp/
から始まる OpenMP
指示文を与えるだけで並列化プログラミングを行える便利なライブラリである
OpenMP \cite{openmp}を使用する．

\begin{figure}[t]
 \lstinputlisting[language=c++]{src/exec_openmp.cc}
 \caption{Exec メソッド内の for 文を OpenMP で並列化したプログラム}
 \label{src:exec_openmp}
\end{figure}

8 スレッドで並列化されるように OpenMP 指示文を与えたものが
\figref{src:exec_openmp} である．

一般に並列化を行う場合は各スレッド対して均等に負荷を与えることが重要である．for
文の負荷を分散するスケジュール方法として静的に決定する static
と，動的に決定する dynamic など複数存在する．今回の ArchHDL
の場合，各モジュールと各レジスタで実行時間が大幅に変わるというのは考えにくい．よって動的に決定するオーバーヘッドを考えると
static を指定した方が効率が良いと考えられる．実際に dynamic
を指定すると遅くなることが確認されている．

他にも OpenMP
にはオプションとしてチャンクサイズ（割り当てサイズ）を指定できる．チャンクサイズを指定するとデフォルトよりも遅くなることが確認されている（具体的な数字を載せるべき？）．

よって今回の評価はスケジュール方法が static
でチャンクサイズは指定しないというデフォルトの設定で行う．
