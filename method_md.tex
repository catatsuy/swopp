## 最適化の方針

ここでは \ref{ss:profiling} 章で述べたように，ArchHDL::Step() と reg::Update() の実行を高速化することを考える．

最適化の方針として逐次プログラミングにおける最適化と並列化における最適化の両方を考える．


## 逐次プログラミングにおける高速化手法

### データ変更の有無による条件分岐の除去 \label{sss:no_set}

これまでの実装は \figref{src:reg} に記すように，reg インスタンスにノンブロッキング代入が行われたときだけ reg::Update 内で次サイクルの値を現在の値に代入する処理が行われている．

この条件分岐を無くして常に現在の値に次サイクルの値が代入されるようにする．こうすることによってノンブロッキング代入が頻繁に行われる回路では速度が向上すると考えられる．


### 逐次代入をメモリーコピーにする \label{sss:mem_copy}

\begin{figure}[t]
 \begin{center}
  \input{img/regs}
 \end{center}
 \caption{現在の reg インスタンスのイメージ}
 \label{fig:regs}
\end{figure}

\figref{fig:regs} は現在の reg インスタンスのイメージである．\ref{sss:no_set} 節で述べたデータ変更の有無による条件分岐の除去を行うと reg::Update() メソッド内で行なっている reg インスタンスの現在の値を格納する変数に次サイクルの値を代入する処理は毎サイクル全 reg インスタンスで実行されることになる．

この代入する処理と reg::Update() メソッド自体の関数呼び出しの
2 つのオーバーヘッドが\tabref{table:stencil_prof} で示すようにArchHDL の高速化を妨げている．

\begin{figure}[t]
 \begin{center}
  \input{img/mem_copy}
 \end{center}
 \caption{逐次代入をメモリーコピーにした reg インスタンスのイメージ}
 \label{fig:mem_copy}
\end{figure}


そこで\figref{fig:mem_copy} のように全 reg インスタンスは現在の値と次サイクルの値の実体は持たず，ポインタを保持するようにする．実体はそれぞれ配列として持つ．そして次サイクルに移る前に行われる現在の値に次サイクルの値を代入する処理をメモリコピーになるように変更する．これにより代入する処理が高速になることが期待される．

またこの手法によって reg::Update() 自体の関数呼び出しがなくなり，関数呼び出しのオーバーヘッドがなくなる．


### ダブルバッファリング

これまでの実装では \ref{ss:implementation} 章で述べたように
reg インスタンスの次サイクルの値が次サイクルに移る前に reg インスタンスの現在の値に代入される．
そこで偶数回目の実行と奇数回目の実行で次サイクルの値と現在の値を格納している変数を
を入れ替えれば（ダブルバッファリング）代入が減ることが期待できる．

\begin{figure}[t]
 \begin{center}
  \input{img/reg_curr_next}
 \end{center}
 \caption{現在の reg インスタンスの変数保持のイメージ}
 \label{fig:reg_curr_next}
\end{figure}

\begin{figure}[t]
 \begin{center}
  \input{img/double_buffer2}
 \end{center}
 \caption{ダブルバッファリングのイメージ}
 \label{fig:double_buffer}
\end{figure}

\figref{fig:reg_curr_next} はこれまでの ArchHDL の reg インスタンスの値の保持のイメージである．読み込み用と書き込み用の変数をそれぞれ保持している．読み込み用が現在の値であり，書き込み用が次サイクルの値である，次サイクルに移る前に書き込み用の値が読み込み用の変数に書き込まれる．

\figref{fig:double_buffer} はダブルバッファリングのイメージである．奇数回目のサイクルと偶数回目のサイクルで読み込み用と書き込み用の変数を入れ替える．これにより奇数回目のサイクルで書き込み用であった変数には値が書き込まれているので次サイクルの偶数回目のサイクルで読み込み用として使用出来る．これを繰り返すことで，次サイクルに移る前に行われる代入処理を無くせる．

しかし今回の手法では reg インスタンスへ値の書き込みが行われなかった場合に
reg インスタンスのその時の書き込み用の値に更新が入らない．次サイクルではその書き込み用の値がそのまま現在の値として使用されるので古い値が使われてしまう．そのため単純に入れ替えるだけの実装では誤ったシュミレーションを行なってしまう．

また今回の手法はサイクルの回数で依存関係が発生するので \ref{ss:parallel} 節で述べる並列化ができない．

よってライブラリの実装として導入するのは困難であるが，reg インスタンスへ常に書き込みが行われるカウンター回路で試したところ効果があった（具体的な数字）．常に reg インスタンスに書き込みが行われるハードウェアシュミレーションを逐次処理で行いたい場合には高い効果が期待できる．

以上の理由から本論文ではダブルバッファリングによる評価は行わない．



## 並列化による高速化 \label{ss:parallel}

一方で並列化による高速化では \figref{src:class_singleton} に示すように
ArchHDL の Singleton クラスの Exec() メソッド内の
for 文内で Module::Always() メソッドと
reg::Update() メソッドは毎サイクル，各クラスの全インスタンスで呼び出されている．
モジュールの実行とレジスタの更新はそれぞれ独立に行えるので容易に並列化が可能である．

今回は for 文などの並列化を行いたい部分の前に \verb/#pragma omp/ から始まる OpenMP 指示文を与えるだけで並列化プログラミングを行える便利なライブラリである OpenMP \cite{openmp}を使用する．

\begin{figure}[t]
 \lstinputlisting[language=c++]{src/exec_openmp.cc}
 \caption{Exec メソッド内の for 文を OpenMP で並列化したプログラム}
 \label{src:exec_openmp}
\end{figure}

8 スレッドで並列化されるように OpenMP 指示文を与えたものが \figref{src:exec_openmp} である．

一般に並列化を行う場合は各スレッド対して均等に負荷を与えることが重要である．for 文の負荷を分散するスケジュール方法として静的に決定する static と，動的に決定する dynamic など複数存在する．今回の ArchHDL の場合，各モジュールと各レジスタで実行時間が大幅に変わるというのは考えにくい．よって動的に決定するオーバーヘッドを考えると static を指定した方が効率が良いと考えられる．実際に dynamic を指定すると遅くなることが確認されている．

他にも OpenMP にはオプションとしてチャンクサイズ（割り当てサイズ）を指定できる．チャンクサイズを指定するとデフォルトよりも遅くなることが確認されている（具体的な数字を載せるべき？）．

よって今回の評価はスケジュール方法が static でチャンクサイズは指定しないというデフォルトの設定で行う．

