## 最適化の方針

ここでは \ref{ss:profiling} 章で述べたように，ArchHDL::Step() と reg::Update() の実行を高速化することを考える．

最適化の方針として逐次プログラミングにおける最適化と並列化における最適化の両方を考える．


## 逐次プログラミングにおける高速化手法

### データ変更の有無による条件分岐の除去 \label{s:no_set}

これまでの実装は \figref{src:reg} に記すように，ArchHDL の実装では reg インスタンス生成時に set_ を false
にしておき，ノンブロッキング代入が行われたときだけ true にすることで
reg::Update() 内の next_ の値を curr_
に代入する処理が next_ の値に変更があった時のみ行われるようにしている．

この set_ 変数を無くして常に代入が行われるようにすると分岐が 1 つ減る．よってノンブロッキング代入が頻繁に行われる回路では速度が向上すると考えられる．


### 逐次代入をメモリーコピーにする

\begin{figure}[t]
 \begin{center}
  \input{img/regs}
 \end{center}
 \caption{現在の reg インスタンスのイメージ}
 \label{fig:reg_curr_next}
\end{figure}

\figref{fig:reg_curr_next} は現在の reg インスタンスのイメージである．\ref{s:no_set} 節で述べたデータ変更の有無による条件分岐の除去を行うと reg::Update() メソッド内で行なっている reg に現在の値に次のサイクルの値を代入する処理は毎サイクル全インスタンスで実行されることになる．

この代入する処理と reg::Update() メソッド自体の関数呼び出しの
2 つのオーバーヘッドが\tabref{table:stencil_prof} で示すようにArchHDL の高速化を妨げている．

\begin{figure}[t]
 \begin{center}
  \input{img/mem_copy}
 \end{center}
 \caption{逐次代入をメモリーコピーにした reg インスタンスのイメージ}
 \label{fig:mem_copy}
\end{figure}


そこで\figref{fig:mem_copy} のように全 reg インスタンスは現在の値と次のサイクルの値の実体は持たず，ポインタを保持するようにする．実体はそれぞれ配列として持つ．そして毎サイクル行われる現在の値に次のサイクルを代入する処理がメモリをコピーするように変更する．
こうすることによって代入する処理が高速になることが期待される．

またこの実装によって reg::Update() 自体の関数呼び出しがなくなり，関数呼び出しのオーバーヘッドがなくなる．それにより ArchHDL::Step() の実行時間が短くなることが期待できる．


### ダブルバッファリング

これまでの実装では \ref{ss:implementation} 章で述べたように
reg インスタンスの next_ の値が次サイクルになる前に reg インスタンスの curr_ に代入される．
そこで偶数回目の実行と奇数回目の実行で next_ と curr_
を入れ替えれば（ダブルバッファリング）代入が減ることが期待できる．

\begin{figure}[t]
 \begin{center}
  \input{img/reg_curr_next}
 \end{center}
 \caption{現在の reg インスタンスの変数保持のイメージ}
 \label{fig:reg_curr_next}
\end{figure}

\begin{figure}[t]
 \begin{center}
  \input{img/double_buffer2}
 \end{center}
 \caption{ダブルバッファリングのイメージ}
 \label{fig:double_buffer}
\end{figure}

\figref{fig:reg_curr_next} はこれまでの ArchHDL の reg インスタンスの値の保持のイメージである．読み込み用と書き込み用それぞれの値を保持し，毎サイクル
\figref{fig:double_buffer} はダブルバッファリングのイメージである．つまり cycle1 では vala_ を curr_ として使用する．valb_ は next_ として使用する．サイクルが終了したら cycle2 に切り替える．これにより cycle1 の時点で next_ であった valb_ には値が書き込まれているので curr_ として使用出来る．これにより毎サイクル行われる代入処理を減らせる．

しかしこの手法では reg への書き込みが行われなかった場合に
reg のその時の next_ の値に更新が入らない．次のサイクルではその next_ がそのまま
curr_ として使用されるので古い値が使われてしまう．そのため単純な実装では Verilog HDL と同じ挙動にならない．

しかし常に reg への書き込みが行われるカウンター回路で簡易的な実装で試したところ効果があった．
なので並列化をしない場合は高速化の手法として使える可能性がある．

しかし OpenMP で Update() メソッドの処理を並列化できないので得策ではない可能性が高い．

そのためダブルバッファリングによる評価は今回行わなかった．




## 並列化による高速化 \label{ss:parallel}

一方で並列化による高速化では \figref{src:class_singleton} に示すように
ArchHDL の Singleton クラスの Exec() メソッド内の
for 文内で Module::Always() メソッドと
reg::Update() メソッドは毎サイクル，各クラスの全インスタンスで呼び出されている．
この for 文を OpenMP により並列化できることが期待できる．

\begin{figure}[t]
 \lstinputlisting[language=c++]{src/exec_openmp.cc}
 \caption{Exec メソッド内の for 文を OpenMP で並列化したプログラム}
 \label{src:exec_openmp}
\end{figure}

8 スレッドで並列化されるように OpenMP の指示句を与えたものが \figref{src:exec_openmp} である．

OpenMP にはオプションとしてチャンクサイズなどを指定できる．デフォルトはスケジュールタイプが
static でチャンクはなしである．今回の ArchHDL の場合はスケジュールタイプを dynamic
にしたり，チャンクサイズを指定するとデフォルトよりも遅くなることが確認されている．

よって ArchHDL の場合はスケジュールタイプが static でチャンクはなしというデフォルトの挙動が効率が良いと考えられる．

