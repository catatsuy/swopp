\ref{ss:implementation} 節で述べた実装は ver1.0 である．

この章ではこの ver1.0 のプロファイリング結果から高速化ができる部分を探し，それを実装する．


## ArchHDL のプロファイリング

今回のプロファイリングは各メソッドの実行にどの程度時間がかかっているかを調べる．プロファイリングには
gprof を利用する．



### 最適化の方針

最適化の方針として逐次プログラミングにおける最適化と並列化における最適化の両方を考える．





## 逐次プログラミングにおける高速化手法




### set_ 変数を無くす \label{s:no_set}

ver1.0 の ArchHDL の実装では `reg` インスタンス生成時に `set_` を `false`
にしておき，ノンブロッキング代入が行われたときだけ `true` にすることで
`Update()` 内の `next_` の値を `curr_`
に代入する処理が `next_` の値に変更があった時のみ行われるようにしている．

この `set_` 変数を無くすと速度が向上するかどうか調べる．このバージョンを
ver1.1 とした．




### ダブルバッファリング

`next_` の値が次の `curr_` になる．
そこで偶数回目の実行と奇数回目の実行で `next_` と `curr_`
を入れ替えれば（ダブルバッファリング）代入が減ることが期待できる．

しかしダブルバッファリングは `reg` への書き込みが行われなかった場合に
`reg` のその時の `next_` の値に更新が入らない．よって次の
`curr_` に古い値が格納されたままになってしまうので単純な実装では Verilog HDL と同じ挙動にならない．

ただし常に `reg` への書き込みが行われるカウンター回路で簡易的な実装で試したところ効果があった．
なので並列化しない場合は高速化の手法として使える可能性がある．

ただし OpenMP で `Update()` メソッドの処理を並列化できないので得策ではない可能性が高い．

そのためダブルバッファリングによる評価は今回行わなかった．


### next_ から curr_ への代入をメモリーコピーにする

\ref{s:no_set} 節で述べたように ver1.1 より
`Update()` メソッド内で行なっているすべての `reg` の `next_`
の値を `curr_` への代入は毎サイクル実行されることになる．

この代入と `Update()` メソッド自体の関数呼び出しの
2 つオーバーヘッドが ArchHDL の高速化を妨げている要因として考えられる．

そこで `curr_`, `next_`
の値を配列として持つようにする．そうすると毎サイクル行われる `next_` から `curr_`
への代入がメモリをコピーするだけで済むような最適化がコンパイラによって行われる．
そのため代入する処理が高速になることが期待される．
また関数呼び出しもなくなるので関数呼び出しのオーバーヘッドもなくなることが期待できる．

そこで十分大きな配列を 2 つ用意してそれぞれに `curr_`, `next_` の値を格納するようにする．
`reg` は `curr_`, `next_` をポインタとして持ち，実体は持たない．

このバージョンを ver2.0 とした．




## 並列化による高速化








